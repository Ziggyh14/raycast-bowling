#include "sample_hash_table.h"
Table* ht;

Table* create_Table(void){

    ht = (Table*) malloc(sizeof(Table));

    if (ht == NULL){
        printf("ERROR: TABLE NOT CREATED\n");
        return NULL;
    }

    ht->capacity = TABLE_CAPACITY;
    ht->length = 0;
    ht->entries = malloc(ht->capacity * sizeof(Entry*));

    if (ht->entries == NULL){
        printf("ERROR: ENTRIES NOT CREATED\n");
        free(ht->entries);
        return NULL;
    }
    return ht;
}

void delete_Table(){
    int i;
    if(ht!=NULL){
        for(i=0;i<TABLE_CAPACITY;i++){
            if(ht->entries[i] != NULL)
                free_Entry(ht->entries[i]);
        }
        free(ht->entries);
        free(ht);
    }
    return;
}

void free_Entry(Entry* e){
    if(e->chunk!=NULL)
        Mix_FreeChunk(e->chunk);
    if(e->next!=NULL)
        free_Entry(e->next);
    free(e);
    return;
}

Entry* hash_lookup (const char* file){

    if(ht == NULL){
        return NULL;
    }
    int i;
    i = djb2_hash(file)%ht->capacity; //index generated by the hash function
    Entry** e = &(ht->entries[i]); ///The address of the Entry pointer found in the index 
    /*
    -IF e is not NULL
    -then there is already an entry at that hash index
    -IF its first in the list, 
    -   RETURN index
    -ELSE
    -   search through list for file, pointing e to it's own next
    -   IF is found then
    -       RETURN entry
    -   ELSE
    -       e now points to the tail of the list at that index so...
    -
    -IF table at max capacity
    -   RETURN NULL
    -CREATE new entry at e
    -   set file name
    -   set chunk data #todo
    -   next is null
    -ELSE
        -RETURN entry
    */

    if(*e != NULL){
        if((strcmp((*e)->file,file)) == 0)
                return *e;

        while((*e)->next != NULL){
            e = &((*e)->next);
            if((strcmp((*e)->file,file)) == 0)
                return *e;

        }
        e = &((*e)->next);
    }

    if(ht->length > ht->capacity){
        printf("capacity is exceeded\n");
        return NULL;
    }

    /*
    - Create new entry to store sample info in
    - Assign data to e, which we know is the next available space at that hash index
    */
    Entry* temp = malloc(sizeof(Entry));
    temp->file = file; 
    temp->next = NULL;

    temp->chunk = Mix_LoadWAV(file);
    if(temp->chunk == NULL){
        printf("Entry not added, ERROR: %s",SDL_GetError());
        free(temp);
        return NULL;
    }

    *e = temp;
    ht->length++; //increase counter of used table entries
    
    return *e;
}

unsigned long djb2_hash(const char *str)
{
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

/*
Print hash table
*/
void print_ht(){
    int i;
    if(ht==NULL)
        return;

    for(i=0;i<TABLE_CAPACITY;i++){
        if(ht->entries[i] == NULL){
            printf("%d:-----\n",i);
        }else{
            printf("%d: ",i);
            Entry* e = ht->entries[i];
            printf("%s, ",e->file);
            while(e->next != NULL){
                e=e->next;
                printf("%s, ",e->file);
            }
            
            printf("\n");
        }
    }
}
